static const char SSAOPOINTSPHEREVERT_TRACE_VERT[] =
"uniform float numSamples; //number of rays\n"
"uniform float hwMax; //max pixels\n"
"uniform float dstep; //step multiplier\n"
"float R; // radius in world coordinates\n"
"float pixelRadius; //radius in screen coordinates\n"
"#extension GL_ARB_texture_rectangle : enable\n"
"uniform sampler2DRect depthMap;\n"
"uniform float dhwidth;\n"
"varying vec3 spherepos;\n"
"varying vec4 color;\n"
"uniform vec2 osg_Viewport;\n"
"uniform float radius;\n"
"varying vec3 rayorigin;\n"
"varying float pointSize;\n"
"uniform int shade;\n"
"uniform int ssao;\n"
"/*uniform*/ float saturation = 0.5;\n"
"uniform float ssaoRadius;\n"
"float width = osg_Viewport.x; \n"
"float height = osg_Viewport.y;\n"
"vec3 worldPosition;\n"
"vec3 screenPosition;\n"
"vec3 normal;\n"
"varying float occlusionValue;\n"
"//------------------------------------------------------------------------------\n"
"vec3 screenSpace( vec3 v )\n"
"{\n"
"   vec4 p = gl_ProjectionMatrix *  vec4( v, 1.0 );\n"
"   p.xyz /= p.w;\n"
"   // clamp x,y to [-1,1]\n"
"   //clamp( p.xy, -1.0, 1.0 );\n"
"   p.xyz *= 0.5;\n"
"   p.xyz += 0.5;\n"
"   p.x *= width;\n"
"   p.y *= height;\n"
"   return p.xyz;   \n"
"}\n"
"//-----------------------------------------------------------------------------\n"
"vec3 ssUnproject( vec3 v )\n"
"{\n"
"  vec4 p = vec4( v, 1.0 );\n"
"  p.x /= width;\n"
"  p.y /= height;\n"
"  p.xyz -= 0.5;\n"
"  p.xyz *= 2.0;\n"
"  p = gl_ProjectionMatrixInverse * p;\n"
"  p.xyz /= p.w;\n"
"  return p.xyz;\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"float projectAtPos( vec3 pos, float r )\n"
"{\n"
"   return distance( screenSpace( pos ), screenSpace( pos + vec3( r, 0., 0 ) ) );\n"
"   //return viewport.y < viewport.x ? distance( screenSpace( pos ), screenSpace( pos + vec3( r, 0., 0 ) ) )\n"
"   //                               : distance( screenSpace( pos ), screenSpace( pos + vec3( 0., r, 0 ) ) );\n"   
"}\n"
"//------------------------------------------------------------------------------\n"
"//cosine of mininum angle used for angle occlusion computation (~30 deg. best)\n"
"const float minCosAngle = 0.2; // ~78 deg. from normal, ~22 deg from tangent plane\n"
"// adjusted pixel radius\n"
"float PR = 1.0;\n"
"// adjusted world space radius\n"
"float PRP = 1.0;\n"
"// attenuation coefficient\n"
"float B = 0.0;\n"
"\n"
"void ComputeRadiusAndOcclusionAttenuationCoeff()\n"
"{\n"
"  // clamp pixel radius to [1.0, max radius]  \n"
"  PR = clamp( pixelRadius, 1.0, hwMax );\n"
"  // set coefficient for occlusion attenuation function 1 / ( 1 + B * dist^2 )\n"
"  // Rw : Rs = NRw : NRs => NRw = Rw * NRs / Rs \n"
"  PRP = R * PR / pixelRadius; // clamp world space radius\n"
"  // the coefficient is set such that the occlusion at maximum distance\n"
"  // is ~ 1/2 of the peak value\n"
"  B = ( 1.0 - 0.1 ) / ( PRP * PRP );\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"// occlusion function for horizontal (y=y0) lines\n"
"float hocclusion( float ds )\n"
"{\n"
" \n"
"  // follow line y = y0 in screen space along negative or positive direction according to ds\n"
"  // where:\n"
"  //    x0 = screenPosition.x\n"
"  //    y0 = screenPosition.y  \n"
"  // each point visible from current fragment (i.e. with z < current z)\n"
"  // will contribute to the occlusion factor\n"
"  int occSteps = 0;  // number of occlusion rays \n"
"  vec3 p = screenPosition;\n"
"  float occl = 0.0; // occlusion\n"
"  float z = 1.0; // z in depth map\n"
"  float dz = 0.; //\n"
"  float dist = 1.; // distance between current point and shaded point \n"
"  float prev = 0.; // previous angular coefficient \n"
"  vec3 I; // vector from point in depth map to shaded point\n"
"  int upperI = int( PR / abs( ds ) );\n"
"  for( int i = 0; i != upperI; ++i )\n"
"  {\n"
"      p.x += ds;\n"
"    z = texture2DRect( depthMap, p.xy ).x;\n"
"    // compute angular coefficient: if angular coefficient\n"
"    // is greater than last computed coefficient it means the point is \n"
"    // visible from screenPosition and therefore occludes it \n"
"    dz = screenPosition.z - z;\n"
"    dist = distance( p.xy, screenPosition.xy );\n"
"    float angCoeff = dz / dist;\n"
"    if( angCoeff > prev )    \n"  
"    {\n"
"      p.z = z;\n"
"      prev = angCoeff;\n"
"      // compute vector from point in world coordinates to point whose\n"
"      // occlusion is being computed\n"
"\n"
"      I = ssUnproject( p ) - worldPosition.xyz;\n"
"      // ADD AO contribution: function of angle between normal and ray\n"
"      float k = dot( normal, normalize( I ) );\n"
"      // if occluded compute occlusion and increment number of occlusion\n"
"      // contributions\n"
"      if( k > minCosAngle )\n"
"      {\n"
"        occl += ( k / ( 1. + B * dot( I, I ) ) );\n"
"        ++occSteps;\n"
"      }\n"
"    }\n"     
"  }\n"
"  // return average occlusion along ray: divide by number of occlusions found \n"
"  return occl / max( 1.0, float( occSteps ) );\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"// occlusion function for vertical (x=x0) lines\n"
"float vocclusion( float ds )\n"
"{\n"
" \n"
"  // follow line x = x0 in screen scpace along negative or positive direction according to ds\n"
"  // where:\n"
"  //    x0 = screenPosition.x\n"
"  //    y0 = screenPosition.y\n"  
"  // each point visible from current fragment (i.e. with z < current z)\n"
"  // will contribute to the occlusion factor\n"
"  int occSteps = 0;  // number of occlusion rays \n"
"  vec3 p = screenPosition;\n"
"  float occl = 0.0; // occlusion\n"
"  float z = 1.0; // z in depth map\n"
"  float dz = 0.; //\n"
"  float dist = 1.; // distance between current point and shaded point \n"
"  float prev = 0.; // previous angular coefficient \n"
"  vec3 I; // vector from point in depth map to shaded point\n"
"  int upperI = int( PR / abs( ds ) );\n"
"  for( int i = 0; i != upperI; ++i )\n"
"  {\n"
"    p.y += ds; \n"
"    z = texture2DRect( depthMap, p.xy ).x;\n"
"    // compute angular coefficient: if angular coefficient\n"
"    // is greater than last computed coefficient it means the point is \n"
"    // visible from screenPosition and therefore occludes it \n"
"    dz = screenPosition.z - z;\n"
"    dist = distance( p.xy, screenPosition.xy );\n"
"    float angCoeff = dz / dist;\n"
"    if( angCoeff > prev )  \n"    
"    {\n"
"      p.z = z;\n"
"      prev = angCoeff;\n"
"      // compute vector from point in world coordinates to point whose\n"
"      // occlusion is being computed\n"
"      I = ssUnproject( p ) - worldPosition.xyz;\n"
"      // ADD AO contribution: function of angle between normal and ray\n"
"      float k = dot( normal, normalize( I ) );\n"
"      // if occluded compute occlusion and increment number of occlusion\n"
"      // contributions\n"
"      if( k > minCosAngle )\n"
"      {\n"
"        occl += ( k / ( 1. + B * dot( I, I ) ) );\n"
"        ++occSteps;\n"
"      }\n"
"    } \n"     
"  }\n"
"  // return average occlusion along ray: divide by number of occlusions found \n"
"  return occl / max( 1.0, float( occSteps ) );\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"// occlusion function for non degenerate (i.e. lines not paralles to x or y axis) lines\n"
"float occlusion( vec2 dir )\n"
"{\n"
"  // compute angular coefficient and steps\n"
"  float m = dir.y / dir.x;\n"
"  \n"
"  // follow line y = m * ( x - x0 ) + y0 in screen space\n"
"  // where:\n"
"  //    m = dir.y / dir.x\n"
"  //    x0 = screenPosition.x\n"
"  //    y0 = screenPosition.y  \n"
"  // each point visible from current fragment (i.e. with z < current z)\n"
"  // will contribute to the occlusion factor\n"
"  int occSteps = 0;  // number of occlusion rays \n"
"  vec3 p = screenPosition;\n"
"  // compute number of i (x) steps\n"
"  // size of radius = sqrt( (num x steps)^2 + (ang. coeff. * num x steps)^2 )\n"
"  int upperI = int( PR * inversesqrt( 1.0 + m * m ) / abs( dstep ) );\n"
"  float occl = 0.0; // occlusion\n"
"  float z = 1.0; // z in depth map\n"
"  float dz = 0.; //\n"
"  float dist = 1.; // distance between current point and shaded point \n"
"  float prev = 0.; // previous angular coefficient \n"
"  vec3 I; // vector from point in depth map to shaded point\n"
"  float ds = sign( dir.x ) * dstep;\n"
"  for( int i = 0; i != upperI; ++i )\n"
"  {\n"
"    p.x += ds;\n"
"    p.y += ds * m;\n"
"    z = texture2DRect( depthMap, p.xy ).x;\n"
"    // compute angular coefficient: if angular coefficient\n"
"    // is greater than last computed coefficient it means the point is \n"
"    // visible from screenPosition and therefore occludes it \n"
"    dz = screenPosition.z - z;\n"
"    dist = distance( p.xy, screenPosition.xy );\n"
"    float angCoeff = dz / dist;\n"
"    if( angCoeff > prev )\n"      
"    {\n"
"      p.z = z;\n"
"      prev = angCoeff;\n"
"      // compute vector from point in world coordinates to point whose\n"
"      // occlusion is being computed\n"
"      I = ssUnproject( p ) - worldPosition.xyz;\n"
"      // ADD AO contribution: function of angle between normal and ray\n"
"      float k = dot( normal, normalize( I ) );\n"
"      // if occluded compute occlusion and increment number of occlusion\n"
"      // contributions\n"
"      if( k > minCosAngle )\n"
"      {\n"
"        occl += ( k / ( 1. + B * dot( I, I ) ) );\n"
"        ++occSteps;\n"
"      }\n"
"    }\n"      
"  }\n"
"\n"
"  // return average occlusion along ray: divide by number of occlusions found \n"
"  return occl / max( 1.0, float( occSteps ) );\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"float ComputeOcclusion()\n"
"{\n"
"    // numSamples is an upper limit fr the number of directions == number of rays\n"
"    // if the 2D (i,j) sample points are laid out on the edges of a square\n"
"    // and numSamples is the total number of points then the number of samples on one edge\n"
"    // is numSamples / 4;\n"
"    // the i and j indices are assumed to be in the range:\n"
"    //  [-(numSamples / 4) / 2, +(numSamples / 4) / 2] == [ -numSamples/8,+numSamples/8 ]\n"
"    int hw = int( max( 1.0, numSamples / 8.0 ) ); \n"	
"    // ppos is [x pixel, y pixel, depth (0..1) ]\n"
"    float occ = 0.0;\n"
"    int i = -hw;\n"
"    int j = -hw;\n"
"    // vertical edges, j = 0 excluded\n"
"    for( ; j != 0; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    for( j = 1; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    i = hw;\n"
"    for( ; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    for( j = 1; j != hw + 1; ++j ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    // horizontal edges, i = 0 excluded\n"
"    j = -hw;\n"
"    for( i = -hw + 1; i != 0; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    for( i = 1; i != hw; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    j = hw;\n"
"    for( i = -hw + 1; i != 0; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) );\n"
"    for( i = 1; i != hw; ++i ) occ += occlusion( vec2( float( i ), float( j ) ) ); \n"
"    // i = 0 and j = 0\n"
"    occ += hocclusion( -dstep );\n"
"    occ += hocclusion( dstep );\n"
"    occ += vocclusion( -dstep );\n"
"    occ += vocclusion( dstep );\n"
"    // divide occlusion by the number of shot rays\n"
"    occ /= max( 1.0, float( 8 * hw - 2 ) );\n"
"    return occ;\n"
"}\n"
"void main(void)\n"
"{\n"
"  if( bool( shade ) ) color = vec4( saturation * gl_Color.rgb + ( 1.0 - saturation ) * vec3( 1., 1., 1. ), gl_Color.a );\n" 
"  vec4 P = gl_ModelViewMatrix * gl_Vertex;\n"
"  spherepos = vec3( P ) / P.w;\n"
"  gl_Position = gl_ProjectionMatrix * P;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  if( perspective )\n"
"  {\n"
"    rayorigin = vec3( 0, 0, 0 );\n"
"  }\n"
"  else\n"
"  {\n"
"    rayorigin = vec3( P.x / P.w, P.y / P.w, 0 );\n"
"  }\n"
"  // compute pixel size\n"
"  vec3 axis = cross( normalize( spherepos - rayorigin ), vec3( 0., 1., 0. ) );\n"
"  vec4 xp1 = gl_ProjectionMatrix * vec4( spherepos - radius * axis, 1.0 );\n"
"  vec4 xp2 = gl_ProjectionMatrix * vec4( spherepos + radius * axis, 1.0 );\n"
"  float xv1 = osg_Viewport.x * .5 * ( xp1.x / xp1.w + 1.0 );\n" 
"  float xv2 = osg_Viewport.x * .5 * ( xp2.x / xp2.w + 1.0 );\n"
"  gl_PointSize = abs( xv1 - xv2 );\n"
"  pointSize = gl_PointSize;\n"
"  if( ssao > 0 )\n"
"  {\n"
"    ComputeRadiusAndOcclusionAttenuationCoeff();\n"
"    R = dhwidth * ssaoRadius;\n"
"    pixelRadius = max( 0.0, projectAtPos( spherepos, R ) );\n"
"    worldPosition = spherepos + vec3( 0., 0., 1.1 * radius + 0.1 );\n"
"    screenPosition = screenSpace( worldPosition );\n"
"    normal = normalize( -worldPosition );\n"
"    occlusionValue = ComputeOcclusion();\n"
"  }\n"
"}\n";
