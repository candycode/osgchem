static const char BOXSPHEREVERT[] =
"uniform bool disable;\n"
"uniform float radius;\n"
"varying vec3 RS;\n"
"varying float c;\n"
"varying float maxsqlength;\n"
"varying vec4 color;\n"
"varying vec3 raydir;\n"
"varying vec3 rayorigin;\n"
"varying vec3 spherepos;\n"
"varying float s;\n"
"void main()\n"
"{\n"
"  if( disable )\n"
"  {\n"
"  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"  rayorigin = gl_Position.xyz / gl_Position.w;\n"
"  }\n" 
"  else\n"
"  {\n"
"  color = vec4( /*gl_MultiTexCoord0.s * */ gl_Color.rgb, gl_Color.a );"
"  float sphereradsq = radius * radius;\n"
"  s = gl_MultiTexCoord0.s;\n"
"  vec4 center = gl_ModelViewMatrix * vec4( gl_MultiTexCoord1.xyz, 1. );\n"
"  spherepos = center.xyz / center.w;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  vec4 p = gl_ModelViewMatrix * gl_Vertex;\n" 
"  gl_ClipVertex = p;\n"
"  if( perspective )\n"
"  {\n"
"    raydir = vec3( p ) / p.w;\n"
"    rayorigin = vec3( 0., 0., 0. );\n"
"  }\n"  
"  else\n"
"  {\n"
"    raydir = vec3( 0., 0., -1. );\n"
"    rayorigin = vec3( p.x / p.w, p.y / p.w, 0 );\n"
"  }\n"
"  RS = rayorigin - spherepos;\n" 
"  float sqlength = dot( RS, RS );\n"
"  maxsqlength = sphereradsq + sqlength;\n"
"  c = sqlength - sphereradsq;\n"
"  gl_Position = gl_ProjectionMatrix * p;\n"
"  }\n"
"}\n";

