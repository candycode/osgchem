static const char COOLAOPOINTSPHEREFRAG[] =
"uniform float radius;\n"
"uniform vec2 osg_Viewport;\n"
"varying vec4 color;\n"
"varying vec3 rayorigin;\n"
"vec3 raydir;\n"
"varying vec3 spherepos;\n"
"float sphereradsq;\n"
"varying float pointSize;\n"
"varying float visibility;\n"
"\n"
"struct I\n"
"{\n"
"  vec3 P;\n"
"  vec3 N;\n"
"  float t;  \n"
"};\n"
"\n"
"const float C1 = 0.429043;\n"
"const float C2 = 0.511664;\n"
"const float C3 = 0.743125;\n"
"const float C4 = 0.886227;\n"
"const float C5 = 0.247708;\n"
"//// Constants for Breezeway lighting\n"
"const vec3 L00  = vec3( 0.3175995,  0.3571678,  0.3784286);\n"
"const vec3 L1m1 = vec3( 0.3655063,  0.4121290,  0.4490332);\n"
"const vec3 L10  = vec3(-0.0071628, -0.0123780, -0.0146215);\n"
"const vec3 L11  = vec3(-0.1047419, -0.1183074, -0.1260049);\n"
"const vec3 L2m2 = vec3(-0.1304345, -0.1507366, -0.1702497);\n"
"const vec3 L2m1 = vec3(-0.0098978, -0.0155750, -0.0178279);\n"
"const vec3 L20  = vec3(-0.0704158, -0.0762753, -0.0865235);\n"
"const vec3 L21  = vec3( 0.0242531,  0.0279176,  0.0335200);\n"
"const vec3 L22  = vec3(-0.2858534, -0.3235718, -0.3586478);\n"
"\n"
"vec3 refcolor = vec3( .1, .1, .1 );\n"
"vec3 lightDir = vec3( 0., 0., -1. );\n"
"vec4 ComputeCoolColor( in vec3 n )\n"
"{\n"
"  float ScaleFactor = 1.0;\n" 
"  vec3 tnorm = faceforward( n, lightDir, n );\n"
"  vec3 DiffuseColor = C1 * L22 * (tnorm.x * tnorm.x - tnorm.y * tnorm.y) +\n"
"                      C3 * L20 * tnorm.z * tnorm.z +\n"
"                      C4 * L00 -\n"
"                      C5 * L20 +\n"
"                      2.0 * C1 * L2m2 * tnorm.x * tnorm.y +\n"
"                      2.0 * C1 * L21  * tnorm.x * tnorm.z +\n"
"                      2.0 * C1 * L2m1 * tnorm.y * tnorm.z +\n"
"                      2.0 * C2 * L11  * tnorm.x +\n"
"                      2.0 * C2 * L1m1 * tnorm.y +\n"
"                      2.0 * C2 * L10  * tnorm.z;\n"
"\n"
"  DiffuseColor   *= vec3( color ) * ScaleFactor + refcolor;\n"
"  return vec4( visibility * DiffuseColor, color.a );\n" 
"}\n"
"// computes intersection of ray with sphere\n"
"I ComputeRaySphereIntersection( vec3 R, vec3 D )\n"
"{\n"
"  I i;\n"
"  i.t = -1.0;\n"
"  vec3 P = R - spherepos;\n"
"  float a = D.x * D.x + D.y * D.y + D.z * D.z;\n"
"  float b = 2.0 * ( D.x * P.x + D.y * P.y + D.z * P.z );\n"
"  float c = P.x * P.x + P.y * P.y + P.z * P.z - sphereradsq;\n"
"  float delta = ( b * b - 4. * a * c );\n"
"  if( delta < 0.0 ) return i;\n"
"  float d = sqrt( delta );\n"
"  a = .5 / a;\n"
"  float t2 = ( -b + d ) * a;\n"
"  float t1 = ( -b - d ) * a;\n"
"  float t = min( t1, t2 );\n"
"  if( t < 0.0 ) return i;\n"
"  i.P = R + t * D;\n"
"  i.N = normalize( i.P - spherepos );\n"
"  i.t = t;\n"
"  return i;\n"
"}\n"
"float kd = visibility * 1.0;\n"
"float ka = 0.02;\n"
"float ks = 0.0;\n"
"float sh = 90.0;\n"
"vec4 ComputeColor( vec3 n )\n"
"{\n"
"  //color.rgb += vec3( .1, .1, .1 );\n"
"  //if( pointSize < 6.0 ) return color;\n"
"  vec3 N = faceforward( n, lightDir, n );\n"
"  float d = dot( N, -normalize( lightDir ) );\n"
"  float s = pow( max( 0.0, dot( vec3( 0, 0, 1 ), reflect( lightDir, N ) ) ), sh );\n"
"  if( length( color.rgb ) < 0.75 ) ks = 0.;\n" 
"  return vec4(  ks * s * refcolor + kd * d * color.rgb + ka * color.rgb, color.a );\n"
"}\n"
"void main(void)\n"
"{\n"
"  if( pointSize > 256.0 || pointSize < 2.0 ) discard;\n"
"  sphereradsq = radius * radius;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  vec3 fc = vec3( gl_FragCoord );// * gl_FragCoord.w;\n"
"  fc.x = gl_FragCoord.x / osg_Viewport.x;\n"
"  fc.y = gl_FragCoord.y / osg_Viewport.y;\n"
"  fc.z = gl_FragCoord.z;\n"
"  fc *= 2.0;\n"
"  fc -= 1.0;\n"
"  vec4 p = gl_ProjectionMatrixInverse * vec4( fc, 1. );\n"
"  if( perspective )\n"
"  {\n"
"    raydir = vec3( p ) / p.w;\n"
"  }  \n"
"  else\n"
"  {\n"
"    raydir = vec3( 0, 0, -1 );\n"
"  }\n"
"  I i = ComputeRaySphereIntersection( rayorigin, raydir );\n"
"  if( i.t < 0.0 ) discard;\n"
"  gl_FragColor = ComputeColor( i.N );	  \n"
"  float z = dot( vec4( i.P, 1 ), gl_ProjectionMatrixTranspose[ 2 ] );\n"
"  float w = dot( vec4( i.P, 1 ), gl_ProjectionMatrixTranspose[ 3 ] );\n"
"  gl_FragDepth = 0.5 * ( z / w + 1.0 );\n"
"}\n";
