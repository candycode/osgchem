static const char SPHEREVERT2[] =
"uniform float radius;\n"
"varying vec3 RS;\n"
"varying float c;\n"
"varying float maxsqlength;\n"
"varying vec4 color;\n"
"varying vec3 raydir;\n"
"varying vec3 rayorigin;\n"
"varying vec3 spherepos;\n"
"varying float tcoord;\n"
"void main()\n"
"{\n"
"  color = gl_Color;"
"  tcoord = gl_MultiTexCoord0.s;\n"
"  float sphereradsq = radius * radius;\n"
"  vec4 center = gl_ModelViewMatrix * vec4( gl_MultiTexCoord1.xyz, 1. );\n"
"  spherepos = center.xyz / center.w;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  vec3 z = normalize( vec3( 0., 0., 0. ) - spherepos );\n"
"  vec3 x = normalize( cross( vec3( 0., 1., 0. ), z ) );\n"
"  vec3 y = normalize( cross( z, x ) );\n"
"  z = cross( x, y );\n"
"  mat4 M;\n"
"  M[ 0 ] = vec4( x, 0. );\n"
"  M[ 1 ] = vec4( y, 0. );\n"
"  M[ 2 ] = vec4( z, 0. );\n"
"  M[ 3 ] = vec4( spherepos, 1. );\n"
"  vec4 p = M * ( gl_Vertex - vec4( gl_MultiTexCoord1.xyz, 0. ) );\n" 
"  gl_ClipVertex = p;\n"
"  if( perspective )\n"
"  {\n"
"    raydir = vec3( p ) / p.w;\n"
"    rayorigin = vec3( 0., 0., 0. );\n"
"  }\n"  
"  else\n"
"  {\n"
"    raydir = vec3( 0., 0., -1. );\n"
"    rayorigin = vec3( p.x / p.w, p.y / p.w, 0 );\n"
"  }\n"
"  RS = rayorigin - spherepos;\n" 
"  float sqlength = dot( RS, RS );\n"
"  maxsqlength = sphereradsq + sqlength;\n"
"  c = sqlength - sphereradsq;\n"
"  gl_Position = gl_ProjectionMatrix * p;\n"
"}\n";

