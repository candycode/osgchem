static const char POINTCYLINDERVERT[] =
"#version 120\n"
"uniform mat4 Q;\n"
"uniform vec3 axis;\n"
"uniform mat4 osg_ViewMatrix;\n"
"uniform mat4 osg_ViewMatrixInverse;\n"
"uniform float hlength;\n"
"uniform vec2 osg_Viewport;\n"
"varying float a;\n"
"varying float b;\n"
"varying float c;\n"
"varying float d;\n"
"varying float e;\n"
"varying float f;\n"
"varying float g;\n"
"varying float h;\n"
"varying float i;\n"
"varying float j;\n"
"varying vec3 rayorigin;\n"
"varying vec3 ccenter;\n"
"varying vec3 tyaxis;\n"
"varying vec4 color;\n"
"varying float pointSize;\n"
"void main()\n"
"{\n"
"  ccenter = ( gl_ModelViewMatrix * gl_Vertex ).xyz;\n"
"  tyaxis = normalize( mat3( osg_ViewMatrix ) * axis ); // should be transpose( inverse( osg_ViewMatrix ) ) * axis;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  vec4 p = gl_ModelViewMatrix * gl_Vertex;\n"
"  gl_ClipVertex = p;\n"
"  if( perspective )\n"
"  {\n"
"    rayorigin = vec3( 0, 0, 0 );\n"
"  }\n"
"  else\n"
"  {\n"
"    rayorigin = vec3( p.x / p.w, p.y / p.w, 0 );\n"
"  }\n"
"  gl_Position = gl_ProjectionMatrix * p;\n"
"  // compute pixel size\n"
"  vec3 axis = cross( normalize( ccenter - rayorigin ), vec3( 0., 1., 0. ) );\n"
"  vec4 xp1 = gl_ProjectionMatrix * vec4( ccenter - hlength * axis, 1.0 );\n"
"  vec4 xp2 = gl_ProjectionMatrix * vec4( ccenter + hlength * axis, 1.0 );\n"
"  xp1.xy = osg_Viewport * 0.5 * ( xp1.xy / xp1.w + 1.0 );\n"
"  xp2.xy = osg_Viewport * 0.5 * ( xp2.xy / xp2.w + 1.0 );\n"
"  gl_PointSize = 1.41 * length( xp1.xy - xp2.xy );\n"
"  pointSize = gl_PointSize;\n"
"  // if pixel size valid\n"
"  if( pointSize > 2.0 && pointSize < 256.0 )\n"
"  {\n"
"    color = gl_Color;\n"
"    mat4 VMI = mat4( mat3( osg_ViewMatrixInverse ) );\n"
"    mat4 VMIT = transpose( VMI );\n"
"    mat4 M = VMIT * Q * VMI;\n"
"    a = M[ 0 ][ 0 ];\n"
"    b = M[ 1 ][ 1 ];\n"
"    c = M[ 2 ][ 2 ];\n"
"    d = M[ 1 ][ 0 ];\n"
"    e = M[ 2 ][ 0 ];\n"
"    f = M[ 2 ][ 1 ];\n"
"    g = M[ 3 ][ 0 ];\n"
"    h = M[ 3 ][ 1 ];\n"
"    i = M[ 3 ][ 2 ];\n"
"    j = M[ 3 ][ 3 ];\n"
"  }\n"
"}\n";