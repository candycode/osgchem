static const char SSAOPOINTSPHEREVERT_TRACE_FRAG[] =
"uniform float dhwidth;\n"
"varying vec3 spherepos;\n"
"varying vec4 color;\n"
"uniform vec2 osg_Viewport;\n"
"uniform float radius;\n"
"varying vec3 rayorigin;\n"
"varying float pointSize;\n"
"uniform int shade;\n"
"uniform int ssao;\n"
"/*uniform*/ float saturation = 0.5;\n"
"varying float pixelRadius;\n"
"varying float R;\n"
"uniform float ssaoRadius;\n"
"float width = 800.0;//osg_Viewport.x; \n"
"float height = 600.0;//osg_Viewport.y;\n"
"//------------------------------------------------------------------------------\n"
"vec3 screenSpace( vec3 v )\n"
"{\n"
"   vec4 p = gl_ProjectionMatrix *  vec4( v, 1.0 );\n"
"   p.xyz /= p.w;\n"
"   // clamp x,y to [-1,1]\n"
"   //clamp( p.xy, -1.0, 1.0 );\n"
"   p.xyz *= 0.5;\n"
"   p.xyz += 0.5;\n"
"   p.x *= width;\n"
"   p.y *= height;\n"
"   return p.xyz;   \n"
"}\n"
"//-----------------------------------------------------------------------------\n"
"vec3 ssUnproject( vec3 v )\n"
"{\n"
"  vec4 p = vec4( v, 1.0 );\n"
"  p.x /= width;\n"
"  p.y /= height;\n"
"  p.xyz -= 0.5;\n"
"  p.xyz *= 2.0;\n"
"  p = gl_ProjectionMatrixInverse * p;\n"
"  p.xyz /= p.w;\n"
"  return p.xyz;\n"
"}\n"
"//------------------------------------------------------------------------------\n"
"float projectAtPos( vec3 pos, float r )\n"
"{\n"
"   return distance( screenSpace( pos ), screenSpace( pos + vec3( r, 0., 0 ) ) );\n"
"   //return viewport.y < viewport.x ? distance( screenSpace( pos ), screenSpace( pos + vec3( r, 0., 0 ) ) )\n"
"   //                               : distance( screenSpace( pos ), screenSpace( pos + vec3( 0., r, 0 ) ) );\n"   
"}\n"
"void main(void)\n"
"{\n"
"  if( bool( shade ) ) color = vec4( saturation * gl_Color.rgb + ( 1.0 - saturation ) * vec3( 1., 1., 1. ), gl_Color.a );\n" 
"  vec4 P = gl_ModelViewMatrix * gl_Vertex;\n"
"  bool perspective = gl_ProjectionMatrix[ 3 ][ 3 ] < 0.001 && gl_ProjectionMatrix[ 2 ][ 3 ] != 0.0;\n"
"  if( perspective )\n"
"  {\n"
"    rayorigin = vec3( 0, 0, 0 );\n"
"  }\n"
"  else\n"
"  {\n"
"    rayorigin = vec3( P.x / P.w, P.y / P.w, 0 );\n"
"  }\n"
"  spherepos = vec3( P ) / P.w;\n"
"  // compute pixel size\n"
"  vec3 raydir = normalize( spherepos - rayorigin );\n"
"  vec3 axis1 = cross( raydir, vec3( 0., 1., 0. ) );\n"
"  vec3 displacedCenter = spherepos - radius * raydir;\n"
"  gl_Position = gl_ProjectionMatrix * vec4( displacedCenter, 1.0 );\n"
"  vec4 xp1 = gl_ProjectionMatrix * vec4( displacedCenter - radius * axis1, 1.0 );\n"
"  vec4 xp2 = gl_ProjectionMatrix * vec4( displacedCenter + radius * axis1, 1.0 );\n"
"  float xv1 = width * .5 * ( xp1.x / xp1.w + 1.0 );\n" 
"  float xv2 = width * .5 * ( xp2.x / xp2.w + 1.0 );\n"
"  gl_PointSize = abs( xv1 - xv2 );\n"
"  pointSize = gl_PointSize;\n"
"  if( ssao > 0 )\n"
"  {\n"
"    R = dhwidth * ssaoRadius;\n"
"    pixelRadius = max( 0.0, projectAtPos( spherepos, R ) );\n"
"  }\n"
"}\n";
