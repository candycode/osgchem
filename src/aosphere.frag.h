static const char AOSPHEREFRAG[] =
"uniform bool disable;\n"
"varying float tcoord;\n"
"varying float c;\n"
"varying float maxsqlength;\n"
"varying vec4 color;\n"
"varying vec3 spherepos;\n"
"varying vec3 rayorigin;\n"
"varying vec3 raydir;\n"
"varying vec3 RS;\n" 
"varying float s;\n"
"vec3 lightDir1 = vec3( 0., 0., -1. );\n"
"vec3 lightDir2 = vec3( 1, -1, -1 );\n"
"vec3 lightDir3 = vec3( -1, 1, -1 );\n"
"vec3 lightDir4 = vec3( 1, 1, -1 );\n"
"float kd = 1.0;\n"
"float ka = 0.0;\n"
"float ks = .5;\n"
"float sh = 90.0;\n"
"vec3 refcolor = vec3( 1, 1, 1 );\n"
"vec4 ComputeColor( vec3 n )\n"
"{\n"
"  vec3 N1 = faceforward( n, lightDir1, n );\n"
"  vec3 N2 = faceforward( n, lightDir2, n );\n"
"  vec3 N3 = faceforward( n, lightDir3, n );\n"
"  vec3 N4 = faceforward( n, lightDir4, n );\n"
"  float d1 = dot( N1, -normalize( lightDir1 ) );\n"
"  float l = length( vec2( dFdx( s ), dFdy( s ) ) );\n"
"  float d2 = 0.;//dot( N2, -normalize( lightDir2 ) );\n"
"  float d3 = 0.;//dot( N3, -normalize( lightDir3 ) );\n"
"  float d4 = 0.;//dot( N4, -normalize( lightDir4 ) );\n"
"  //float s = pow( max( 0.0, dot( vec3( 0, 0, 1 ), reflect( lightDir, N ) ) ), sh );\n"
"  //s = 1.58197671 * ( 1. - exp( -sqrt( s ) ) );\n"
"  s = pow( s, .333334 );\n"
"  //float m = length( vec2( dFdx( s ), dFdy( s ) ) );\n"
"  //if( m > 0.1 ) s = s * m;\n"  
"  //s = 1.0;\n"
"  return vec4( kd * s * ( d1 * color.rgb + d2 * color.rgb + d3 * color.rgb + d4 * color.rgb ) + ka * color.rgb, color.a );\n"
"  //return vec4( dFdx( s ), dFdy( s ), 0.0, color.a );\n"
"}\n"
"void main(void)\n"
"{\n"
"  if( disable )\n"
"  {\n"
"     gl_FragColor = vec4( 1., 1., 1., 1. );\n"
"	  gl_FragDepth = 0.5 *( rayorigin.z + 1.0 );\n"	
"  }\n"
"  else\n"
"  {\n"
"  float a = dot( raydir, raydir );\n"
"  if( a > maxsqlength ) discard;\n"
"  float b = 2.0 * dot( RS, raydir );\n"
"  float delta = ( b * b - 4. * a * c );\n"
"  if( delta < 0.0 ) discard;\n"
"  float d = sqrt( delta );\n"
"  a = 1. / a;\n"
"  a *= .5;\n"
"  float t2 = ( -b + d ) * a;\n"
"  float t1 = ( -b - d ) * a;\n"
"  float t = min( t1, t2 );\n"
"  if( t < 0.0 ) discard;\n"
"  vec3 P = rayorigin + t * raydir;\n"
"  vec3 N = normalize( P - spherepos );\n"
"  gl_FragColor = ComputeColor( N );\n"	  
"  float z = dot( vec4( P, 1 ), gl_ProjectionMatrixTranspose[ 2 ] );\n"
"  float w = dot( vec4( P, 1 ), gl_ProjectionMatrixTranspose[ 3 ] );\n"
"  gl_FragDepth = 0.5 * ( z / w + 1.0 );\n"
"  }\n"
"}\n";



